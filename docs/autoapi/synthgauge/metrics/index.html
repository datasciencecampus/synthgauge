<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>synthgauge.metrics &mdash; SynthGauge 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="synthgauge.metrics.classification" href="classification/index.html" />
    <link rel="prev" title="synthgauge" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> SynthGauge
            <img src="../../../_static/favicon.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge</span></code></a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#package-contents">Package Contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SynthGauge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">API Reference</a> &raquo;</li>
          <li><a href="../index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge</span></code></a> &raquo;</li>
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/autoapi/synthgauge/metrics/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-synthgauge.metrics">
<span id="synthgauge-metrics"></span><h1><a class="reference internal" href="#module-synthgauge.metrics" title="synthgauge.metrics"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics</span></code></a><a class="headerlink" href="#module-synthgauge.metrics" title="Permalink to this heading"></a></h1>
<p>A submodule for all utility and privacy metrics.</p>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="classification/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics.classification</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="cluster/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics.cluster</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="correlation/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics.correlation</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="density/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics.density</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="privacy/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics.privacy</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="propensity/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics.propensity</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="univariate/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synthgauge.metrics.univariate</span></code></a></li>
</ul>
</div>
</section>
<section id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Permalink to this heading"></a></h2>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#synthgauge.metrics.classification_comparison" title="synthgauge.metrics.classification_comparison"><code class="xref py py-obj docutils literal notranslate"><span class="pre">classification_comparison</span></code></a>(real, synth, feats, target, classifier, test_prop=0.2, random_state=None, **kwargs)</p></td>
<td><p>Classification utility metric.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#synthgauge.metrics.clustered_msd" title="synthgauge.metrics.clustered_msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clustered_msd</span></code></a>(real, synth, feats=None, method='kmeans', k_min=2, k_max=10, random_state=None)</p></td>
<td><p>(Multiple) clustered mean-squared difference (MSD).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#synthgauge.metrics.correlation_msd" title="synthgauge.metrics.correlation_msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation_msd</span></code></a>(real, synth, method='pearson', feats=None)</p></td>
<td><p>Mean-squared difference in correlation coefficients.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#synthgauge.metrics.correlation_ratio_msd" title="synthgauge.metrics.correlation_ratio_msd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation_ratio_msd</span></code></a>(real, synth, categorical=None, numeric=None)</p></td>
<td><p>Correlation ratio mean-squared difference.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#synthgauge.metrics.feature_density_mad" title="synthgauge.metrics.feature_density_mad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_density_mad</span></code></a>(real, synth, feats=None, bins=10)</p></td>
<td><p>Mean absolute difference of feature densities.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#synthgauge.metrics.min_nearest_neighbour" title="synthgauge.metrics.min_nearest_neighbour"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_nearest_neighbour</span></code></a>(real, synth, feats=None, outliers_only=True, threshold=2, n_neighbours=5)</p></td>
<td><p>Minimum nearest-neighbour distance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#synthgauge.metrics.sample_overlap_score" title="synthgauge.metrics.sample_overlap_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_overlap_score</span></code></a>(real, synth, feats=None, sample_size=0.2, runs=5, seed=None, score_type='unique')</p></td>
<td><p>Return percentage of overlap between real and synth data based on</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#synthgauge.metrics.tcap_score" title="synthgauge.metrics.tcap_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tcap_score</span></code></a>(real, synth, key, target)</p></td>
<td><p>Target Correct Attribution Probability (TCAP) score.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#synthgauge.metrics.propensity_metrics" title="synthgauge.metrics.propensity_metrics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">propensity_metrics</span></code></a>(real, synth, method='cart', feats=None, num_perms=20, **kwargs)</p></td>
<td><p>Propensity score-based metrics.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#synthgauge.metrics.jensen_shannon_distance" title="synthgauge.metrics.jensen_shannon_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">jensen_shannon_distance</span></code></a>(real, synth, feature, bins='auto', **kwargs)</p></td>
<td><p>Jensen-Shannon distance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#synthgauge.metrics.jensen_shannon_divergence" title="synthgauge.metrics.jensen_shannon_divergence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">jensen_shannon_divergence</span></code></a>(real, synth, feature, bins='auto', **kwargs)</p></td>
<td><p>Jensen-Shannon divergence.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#synthgauge.metrics.kolmogorov_smirnov" title="synthgauge.metrics.kolmogorov_smirnov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kolmogorov_smirnov</span></code></a>(real, synth, feature, **kwargs)</p></td>
<td><p>Kolmogorov-Smirnov test.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#synthgauge.metrics.kruskal_wallis" title="synthgauge.metrics.kruskal_wallis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kruskal_wallis</span></code></a>(real, synth, feature, **kwargs)</p></td>
<td><p>Kruskal-Wallis H test.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#synthgauge.metrics.kullback_leibler" title="synthgauge.metrics.kullback_leibler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kullback_leibler</span></code></a>(real, synth, feature, bins='auto', **kwargs)</p></td>
<td><p>Kullback-Leibler divergence.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#synthgauge.metrics.mann_whitney" title="synthgauge.metrics.mann_whitney"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mann_whitney</span></code></a>(real, synth, feature, **kwargs)</p></td>
<td><p>Mann-Whitney U test.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#synthgauge.metrics.wasserstein" title="synthgauge.metrics.wasserstein"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wasserstein</span></code></a>(real, synth, feature, **kwargs)</p></td>
<td><p>The (first) Wasserstein distance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#synthgauge.metrics.wilcoxon" title="synthgauge.metrics.wilcoxon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wilcoxon</span></code></a>(real, synth, feature, **kwargs)</p></td>
<td><p>Wilcoxon signed-rank test.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.classification_comparison">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">classification_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feats</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_prop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/classification.html#classification_comparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.classification_comparison" title="Permalink to this definition"></a></dt>
<dd><p>Classification utility metric.</p>
<p>This metric fits two (identical) classification models to <cite>real</cite> and
<cite>synth</cite>, and then tests them both against withheld <cite>real</cite> data. We
obtain utility scores by subtracting the precision, recall and f1
scores of the “synthetic” model predictions from the “real” model’s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feats</strong> (<em>list of str</em>) – List of column names to use as the input in the classification.</p></li>
<li><p><strong>target</strong> (<em>str</em>) – Column to use as target in the classification.</p></li>
<li><p><strong>classifier</strong> (<em>scikit-learn estimator</em>) – Classifier class with <cite>fit</cite> and <cite>predict</cite> methods.</p></li>
<li><p><strong>test_prop</strong> (<em>float</em><em> or </em><em>int</em><em>, </em><em>default 0.2</em>) – If <cite>float</cite>, should be between 0.0 and 1.0 and represent the
proportion of the dataset to include in the test split. If
<cite>int</cite>, represents the absolute number of test samples.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>optional</em>) – Random seed for shuffling during the train-test split, and for
the classification algorithm itself.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – featsword arguments passed to the classifier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>precision_difference</strong> (<em>float</em>) – Precision of the real model subtracted by that of the
synthetic model.</p></li>
<li><p><strong>recall_difference</strong> (<em>float</em>) – Recall of the real model subtracted by that of the synthetic
model.</p></li>
<li><p><strong>f1_difference</strong> (<em>float</em>) – f1 score of the real model subtracted by that of the
synthetic model.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Some preprocessing is carried out before the models are trained.
Numeric features are scaled and categorical features are
one-hot-encoded.</p>
<p>A score of zero tells us the synthetic data is just as good as the
real at training the given classification model. Increases in these
scores indicate poorer utility.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.clustered_msd">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">clustered_msd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kmeans'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/cluster.html#clustered_msd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.clustered_msd" title="Permalink to this definition"></a></dt>
<dd><p>(Multiple) clustered mean-squared difference (MSD).</p>
<p>This metric clusters the real and synthetic data together, measuring
the synthetic utility according to its representation across the
fitted clusters. Since there is often no obvious choice for the
number of clusters, <span class="math notranslate nohighlight">\(k\)</span>, we consider a range of values.</p>
<p>For each value of <span class="math notranslate nohighlight">\(k\)</span>, the chosen clustering method is fit
and the proportion of synthetic data in each cluster is recorded.
The clustered MSD is then calculated as the mean-squared difference
between these proportions and the overall proportion of synthetic
data.</p>
<p>This collection of MSDs is summarised by taking its minimum to give
the metric value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feats</strong> (<em>list of str</em><em> or </em><em>None</em><em>, </em><em>default None</em>) – Features to use in the clustering. If <cite>None</cite> (default), all
common features are used.</p></li>
<li><p><strong>method</strong> (<em>{&quot;kmeans&quot;</em><em>, </em><em>&quot;kprototypes&quot;}</em><em>, </em><em>default &quot;kmeans&quot;</em>) – Clustering method to use. Only k-means and k-prototypes
are implemented. If using k-means (default), only numeric
columns are considered, while k-prototypes allows for mixed-type
clustering.</p></li>
<li><p><strong>k_min</strong> (<em>int</em><em>, </em><em>default 2</em>) – Minimum number of clusters to use. Default of 2.</p></li>
<li><p><strong>k_max</strong> (<em>int</em><em>, </em><em>default 10</em>) – Maximum number of clusters to use. Default of 10.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>optional</em>) – The random seed used to fit the clustering algorithm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The minimum observed clustered MSD.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function can be used with a single value of <cite>k</cite> by setting
<cite>k_min</cite> and <cite>k_max</cite> both to <cite>k</cite>. For instance, if a sensible number
of clusters is known a priori.</p>
<p>This metric says nothing about how appropriate the clustering method
may be for the data at hand, nor how the data are distributed among
the clusters. Both methods considered here have rather strong
assumptions about the relative size and characteristics of the
clusters in the data. As such, exploratory analysis is advised to
determine whether such centroid-based clustering is well-suited.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.correlation_msd">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">correlation_msd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pearson'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/correlation.html#correlation_msd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.correlation_msd" title="Permalink to this definition"></a></dt>
<dd><p>Mean-squared difference in correlation coefficients.</p>
<p>This metric calculates the mean squared difference between the
correlation matrices for the real and synthetic datasets. This gives
an indication of how well the synthetic data has retained bivariate
relationships.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>method</strong> (<em>{&quot;pearson&quot;</em><em>, </em><em>&quot;spearman&quot;</em><em>, </em><em>&quot;cramers_v&quot;}</em><em>, </em><em>default &quot;pearson&quot;</em>) – </p></li>
<li><p><strong>feats</strong> (<em>list of str</em><em> or </em><em>None</em><em>, </em><em>default None</em>) – Features to measure correlation across. If <cite>method=”cramers_v”</cite>,
all numeric columns will be filtered out. Likewise, for the
other correlation methods, all non-numeric columns are removed.
If <cite>None</cite> (default), all common features that satisfy the needs
of <cite>method</cite> are used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Mean-squared difference of correlation coefficients.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.corrcoef</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The smaller the number this function returns, the better the
synthetic data captures the correlation between variables in the
real data. This method is therefore good for comparing multiple
synthetic datasets to see which is closest to the real. However, as
this is not a test, there is no threshold value below which we can
claim the datasets are statistically the same.</p>
<p>We only consider the coefficients above the main diagonal when
calculating the MSD. If we included the entire matrix, we would
double-count each pair of features as well as including the trivial
ones along the main diagonal.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.correlation_ratio_msd">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">correlation_ratio_msd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">categorical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numeric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/correlation.html#correlation_ratio_msd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.correlation_ratio_msd" title="Permalink to this definition"></a></dt>
<dd><p>Correlation ratio mean-squared difference.</p>
<p>This metric calculates the mean-squared difference in association
between categorical and continuous feature pairings in the real and
synthetic datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>categorical</strong> (<em>list of str</em><em> or </em><em>None</em><em>, </em><em>default None</em>) – Categorical features in <cite>real</cite> and <cite>synth</cite> to include in
comparison. If <cite>None</cite> (default), uses all common object-type
columns.</p></li>
<li><p><strong>numeric</strong> (<em>list of str</em><em> or </em><em>None</em><em>, </em><em>default None</em>) – Numerical features in <cite>real</cite> and <cite>synth</cite> to include in
comparison. If <cite>None</cite> (default), uses all common columns not
selected by <cite>categorical</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Mean squared difference between <cite>real</cite> and <cite>synth</cite> in
correlation ratio scores across all categorical-continuous
feature pairs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.feature_density_mad">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">feature_density_mad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/density.html#feature_density_mad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.feature_density_mad" title="Permalink to this definition"></a></dt>
<dd><p>Mean absolute difference of feature densities.</p>
<p>For each feature the difference between the density across the bins
within <cite>real</cite> and <cite>synth</cite> is calculated. Finally the MAE across all
features and bins is calculated. A value close to 0 indicates that
the real and synthetic datasets have a similar set of feature
distributions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – DataFrame containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – DataFrame containing the sythetic data.</p></li>
<li><p><strong>feats</strong> (<em>list of str</em><em> or </em><em>None</em><em>, </em><em>default None</em>) – The features that will be used to compute the densities. If
<cite>None</cite> (default), all common features are used.</p></li>
<li><p><strong>bins</strong> (<em>str</em><em> or </em><em>int</em><em>, </em><em>default 10</em>) – Binning method for discretising the data. Can be anything
accepted by <cite>numpy.histogram_bin_edges</cite>. Default uses 10 bins.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Mean absolute error of feature densities.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.min_nearest_neighbour">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">min_nearest_neighbour</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outliers_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_neighbours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/privacy.html#min_nearest_neighbour"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.min_nearest_neighbour" title="Permalink to this definition"></a></dt>
<dd><p>Minimum nearest-neighbour distance.</p>
<p>This privacy metric returns the smallest distance between any point
in the real dataset and any point in the synthetic dataset. There is
an option to only consider the outliers in the real dataset as these
perhaps pose more of a privacy concern.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feats</strong> (<em>list of str</em><em> or </em><em>None</em><em>, </em><em>default None</em>) – Features in <cite>real</cite> and <cite>synth</cite> to use when calculating
distance. If <cite>None</cite> (default), all common features are used.</p></li>
<li><p><strong>outliers_only</strong> (<em>bool</em><em>, </em><em>default True</em>) – Boolean indicating whether to filter out the real data inliers
(default) or not.</p></li>
<li><p><strong>threshold</strong> (<em>number</em><em>, </em><em>default 2</em>) – Outlier decision threshold. Increase to include fewer points
from <cite>real</cite> in nearest-neighbour calculations.</p></li>
<li><p><strong>n_neighbours</strong> (<em>int</em><em>, </em><em>default 5</em>) – Number of neighbours to consider when identifying local
outliers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Minimum Manhattan distance between <cite>real</cite> and <cite>synth</cite> data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This privacy metric provides an insight into whether the synthetic
dataset is too similar to the real dataset. It does this by
calculating the minimum distance between the real records and the
synthetic records.</p>
<p>This metric assumes that categorical data is ordinal during distance
calculations, or that it has already been suitably one-hot-encoded.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.sample_overlap_score">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">sample_overlap_score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">runs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unique'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/privacy.html#sample_overlap_score"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.sample_overlap_score" title="Permalink to this definition"></a></dt>
<dd><p>Return percentage of overlap between real and synth data based on
random sampling.</p>
<p>Samples from both the real and synthetic datasets are compared for
similarity. This similarity, or overlap score, is based on the
exact matches of real data records within the synthetic data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feats</strong> (<em>list of str</em><em> or </em><em>None</em><em>, </em><em>default None</em>) – The features used to match records. If <cite>None</cite> (default), all
common features are used.</p></li>
<li><p><strong>sample_size</strong> (<em>float</em><em> or </em><em>int</em><em>, </em><em>default 0.2</em>) – The ratio (if <cite>sample_size</cite> between 0 and 1) or count
(<cite>sample_size</cite> &gt; 1) of records to sample. Default is 0.2 (20%).</p></li>
<li><p><strong>runs</strong> (<em>int</em><em>, </em><em>default 5</em>) – The number of sampling runs to use when computing the score.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Random number seed used for sampling.</p></li>
<li><p><strong>score_type</strong> (<em>{&quot;unique&quot;</em><em>, </em><em>&quot;sample&quot;}</em><em>, </em><em>default &quot;unique&quot;</em>) – Method used for calculating the overlap score. If “unique”
(default), the score is the percentage of unique records in the
real sample that have a match within the synthetic data. If
“sample”, the score is the percentage of all records within the
real sample that have a match within the synth sample.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>overlap_score</strong> – Estimated overlap score between <cite>real</cite> and <cite>synth</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.tcap_score">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">tcap_score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/privacy.html#tcap_score"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.tcap_score" title="Permalink to this definition"></a></dt>
<dd><p>Target Correct Attribution Probability (TCAP) score.</p>
<p>This privacy metric calculates the average chance that the
key-target pairings in a synthetic dataset reveal the true
key-target pairings in associated real dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>key</strong> (<em>list of str</em>) – List of features in <cite>synth</cite> to use as the key.</p></li>
<li><p><strong>target</strong> (<em>str</em>) – Feature to use as the target.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The average TCAP score across the dataset.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This metric provides an estimate of how well an intruder could infer
attributes of groups in the real dataset by studying the synthetic.
The choices for <cite>key</cite> and <cite>target</cite> will vary depending on the
dataset in question but we would suggest the <cite>key</cite> features are
those that could be readily available to an outsider and the
<cite>target</cite> feature is one we wouldn’t want them finding out, such as a
protected characteristic.</p>
<p>This method only works with categorical data, so binning of
continuous data may be required.</p>
<p>Full details may be found in:</p>
<p>Taub and Elliott (2019). The Synthetic Data Challenge. The Hague,
The Netherlands: Joint UNECE/Eurostat Work Session on Statistical
Data Confidentiality, Session 3.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.propensity_metrics">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">propensity_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cart'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/propensity.html#propensity_metrics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.propensity_metrics" title="Permalink to this definition"></a></dt>
<dd><p>Propensity score-based metrics.</p>
<p>This function calculates three metrics based on the propensity score
mean-squared error (pMSE), all of which quantify utility by
measuring the distinguishability of the synthetic data. That is, how
readily real and synthetic data can be identified.</p>
<p>To do this, the datasets are combined and their origins tracked by a
boolean indicator. This combined dataset is then used to fit a
binary classification model (CART or logistic regression with
first-order interactions) with the indicator as the target. The
propensity score for each row is then extracted and summarised to
give a metric.</p>
<p>The returned metrics are the observed pMSE along with the pMSE ratio
and standardised pMSE. These second two metrics are given relative
to the null case where the real and synthetic data are produced from
identical processes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>method</strong> (<em>{&quot;cart&quot;</em><em>, </em><em>&quot;logr&quot;}</em><em>, </em><em>default &quot;cart&quot;</em>) – Which propensity model to use. Must be either CART (<cite>“cart”</cite>) or
logistic regression with first-order interactions (<cite>“logr”</cite>).</p></li>
<li><p><strong>feats</strong> (<em>list of str</em><em> or </em><em>None</em><em>, </em><em>default None</em>) – List of features in the dataset to be used in the propensity
model. If <cite>None</cite> (default), all common features are used.</p></li>
<li><p><strong>num_perms</strong> (<em>int</em><em>, </em><em>default 20</em>) – Number of permutations to consider when estimating the null case
statistics with a CART model.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments passed to the propensity model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>observed</strong> (<em>float</em>) – The observed pMSE.</p></li>
<li><p><strong>standard</strong> (<em>float</em>) – The null-standardised pMSE.</p></li>
<li><p><strong>ratio</strong> (<em>float</em>) – The observed-null pMSE ratio.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>method</cite> is not one of <cite>‘cart’</cite> or <cite>‘logr’</cite>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sklearn.linear_model.LogisticRegression</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">sklearn.tree.DecisionTreeClassifier</span></code>, <a class="reference internal" href="propensity/index.html#synthgauge.metrics.propensity.pmse" title="synthgauge.metrics.propensity.pmse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">synthgauge.metrics.propensity.pmse</span></code></a>, <a class="reference internal" href="propensity/index.html#synthgauge.metrics.propensity.pmse_ratio" title="synthgauge.metrics.propensity.pmse_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">synthgauge.metrics.propensity.pmse_ratio</span></code></a>, <a class="reference internal" href="propensity/index.html#synthgauge.metrics.propensity.pmse_standardised" title="synthgauge.metrics.propensity.pmse_standardised"><code class="xref py py-obj docutils literal notranslate"><span class="pre">synthgauge.metrics.propensity.pmse_standardised</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For the CART model, <cite>sklearn.tree.DecisionTreeClassifier</cite> is used.
Meanwhile, the logistic regression model uses
<cite>sklearn.linear_model.LogisticRegression</cite>.</p>
<p>Note that the <cite>random_state</cite> keyword argument is used to
(independently) create the permutations and to fit the model when
using a CART model. Without specifying this, the results will not be
reproducible.</p>
<p>Details on these metrics can be found at:
<a class="reference external" href="https://doi.org/10.1111/rssa.12358">https://doi.org/10.1111/rssa.12358</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.jensen_shannon_distance">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">jensen_shannon_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/univariate.html#jensen_shannon_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.jensen_shannon_distance" title="Permalink to this definition"></a></dt>
<dd><p>Jensen-Shannon distance.</p>
<p>Describes the difference between two distributions in terms of
entropy. Calculated as the square root of the Jensen-Shannon
divergence, the Jensen-Shannon distance satisfies the mathematical
definition of a metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feature</strong> (<em>str</em>) – Feature of the datasets to compare. This must be continuous.</p></li>
<li><p><strong>bins</strong> (<em>int</em><em> or </em><em>str</em><em> or </em><em>None</em><em>, </em><em>default &quot;auto&quot;</em>) – The binning method to use. If <cite>int</cite>, is the number of bins. If
<cite>str</cite>, must be a method accepted by <cite>numpy.histogram_bin_edges</cite>.
If <cite>None</cite>, the feature is assumed to be categorical and counts
are taken for each value in either dataset.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments for <cite>scipy.spatial.distance.jensenshannon</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>distance</strong> – The computed distance between the distributions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">synthgauge.metrics.univariate_distance.jensen_shannon_divergence</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.spatial.distance.jensenshannon</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This is a wrapper for <cite>scipy.spatial.distance.jensenshannon</cite>. Since
this function expects probability vectors, the data is first
discretised into evenly-spaced bins.</p>
<p>We can think of the Jensen-Shannon distance as the amount of
information, or entropy, encoded in the difference between the
<cite>real</cite> and <cite>synth</cite> distributions of the <cite>feature</cite>.</p>
<p>The distance is zero if the distributions are identical, and is
bounded above by one if they are nothing alike. This method is
therefore good for comparing multiple synthetic datasets, or
features within a dataset, to see which is closest to the real.
However, as this is not a test, there is no threshold distance below
which we can claim the distributions are statistically the same.</p>
<p>An optimal ‘bins’ value has not been suggested.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_real</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">synth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_synth</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The first feature appears to be more similar than the second across
datasets.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jensen_shannon_distance</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">0.11006632967333475 # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jensen_shannon_distance</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">0.43556476029981644 # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.jensen_shannon_divergence">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">jensen_shannon_divergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/univariate.html#jensen_shannon_divergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.jensen_shannon_divergence" title="Permalink to this definition"></a></dt>
<dd><p>Jensen-Shannon divergence.</p>
<p>Also known as the information radius, the Jensen-Shannon divergence
describes the similarity between two probability distributions in
terms of entropy. This divergence modifies the Kullback-Leibler
divergence to be symmetric and finite (between 0 and 1).</p>
<p>The divergence does not satisfy the triangle inequality. Thus, it
does not describe “distance” in the mathematical sense. Taking its
square root provides a metric known as the Jensen-Shannon distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feature</strong> (<em>str</em>) – Feature of the datasets to compare. This must be continuous.</p></li>
<li><p><strong>bins</strong> (<em>int</em><em> or </em><em>str</em><em> or </em><em>None</em><em>, </em><em>default &quot;auto&quot;</em>) – The binning method to use. If <cite>int</cite>, is the number of bins. If
<cite>str</cite>, must be a method accepted by <cite>numpy.histogram_bin_edges</cite>.
If <cite>None</cite>, the feature is assumed to be categorical and counts
are taken for each value in either dataset.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments for <cite>scipy.spatial.distance.jensenshannon</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The computed divergence between the distributions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">synthgauge.metrics.univariate_distance.jensen_shannon_distance</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.spatial.distance.jensenshannon</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This is a wrapper of
<cite>synthgauge.metrics.univariate_distance.jensen_shannon_distance</cite>,
which in turn wraps <cite>scipy.spatial.distance.jensenshannon</cite>. Since
this function expects probability vectors, the data is first
discretised into evenly-spaced bins.</p>
<p>We can think of the Jensen-Shannon divergence as the amount of
information, or entropy, encoded in the difference between the
real and synthetic distributions of the feature.</p>
<p>The divergence is zero if the distributions are identical, and is
bounded above by one if they are nothing alike. This method is
therefore good for comparing multiple synthetic datasets, or
features within a dataset, to see which is closest to the real.
However, as this is not a test, there is no threshold distance below
which we can claim the distributions are statistically the same.</p>
<p>An optimal ‘bins’ value has not been suggested.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_real</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">synth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_synth</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The first feature appears to be more similar than the second across
datasets.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jensen_shannon_divergence</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">0.11006632967333475 # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jensen_shannon_divergence</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">0.43556476029981644 # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.kolmogorov_smirnov">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">kolmogorov_smirnov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/univariate.html#kolmogorov_smirnov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.kolmogorov_smirnov" title="Permalink to this definition"></a></dt>
<dd><p>Kolmogorov-Smirnov test.</p>
<p>The Kolmogorov-Smirnov test statistic is the maximum difference
between the cumulative distribution functions of the real and
synthetic features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feature</strong> (<em>str</em>) – Name of the feature to compare. This must be continuous.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments for <cite>scipy.stats.ks_2samp</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>statistic, pvalue</strong> (<em>float</em>) – Kolmogorov-Smirnov test statistic.</p></li>
<li><p><strong>pvalue</strong> (<em>float</em>) – Two-tailed p-value.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.ks_2samp</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This is a wrapper for <cite>scipy.stats.ks_2samp</cite>, which tests whether
two samples are drawn from the same distribution by calculating the
maximum difference between their cumulative distribution functions.</p>
<p>If the returned statistic is small or the p-value is high, then we
cannot reject the hypothesis that the distributions are the same.</p>
<p>This approach is only defined if the feature is continuous. The
documentation further suggests this method works best when one of
the samples has a size of only a few thousand.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_real</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">synth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_synth</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The first feature appears to come from the same distribution in both
datasets.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kolmogorov_smirnov</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat1&#39;</span><span class="p">)</span>
<span class="go">KstestResult(statistic=0.062, pvalue=0.2919248807417811) # random</span>
</pre></div>
</div>
<p>The second feature appears to come from different distributions in
the datasets.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kolmogorov_smirnov</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">)</span>
<span class="go">KstestResult(statistic=0.274, pvalue=6.383314923658339e-17) # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.kruskal_wallis">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">kruskal_wallis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/univariate.html#kruskal_wallis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.kruskal_wallis" title="Permalink to this definition"></a></dt>
<dd><p>Kruskal-Wallis H test.</p>
<p>The Kruskal-Wallis test seeks to determine whether two sets of data
originated from the same distribution. This is acheived by pooling
and ranking the datasets. A low p-value suggests the two sets
originate from different distributions and are not similar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feature</strong> (<em>str</em>) – Feature of the datasets to compare. This must be continuous.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments for <cite>scipy.stats.kruskal</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>statistic</strong> (<em>float</em>) – The Kruskal-Wallis H statistic.</p></li>
<li><p><strong>pvalue</strong> (<em>float</em>) – The p-value for the test.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.kruskal</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This is a wrapper function for <cite>scipy.stats.kruskal</cite>.</p>
<p>The null hypothesis for this test is that the medians of the
distributions are equal. The alternative hypothesis is then that
they are different. This would suggest that the synthetic and real
data are not similarly distributed.</p>
<p>We notice, however, that failure to reject the null hypothesis only
suggests that the medians could be equal and says nothing else about
how the data are distributed.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_real</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">synth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_synth</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>If we were to choose our p-value threshold as 0.05, we would reach
the conclusion that the distributions of the first feature are
similar but the distributions of the second feature are not.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kruskal_wallis</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">KruskalResult(statistic=1.4447530549450676, pvalue=0.22937173881858086)</span>
<span class="go"># random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kruskal_wallis</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">KruskalResult(statistic=5.1566145854149, pvalue=0.023157995217201643)</span>
<span class="go"># random</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.kullback_leibler">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">kullback_leibler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/univariate.html#kullback_leibler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.kullback_leibler" title="Permalink to this definition"></a></dt>
<dd><p>Kullback-Leibler divergence.</p>
<p>Describes how much the synthetic feature distribution varies from
the real distribution in terms of relative entropy. The divergence
is assymmetric and does not satisfy the triangle inequality. Thus,
it does not describe “distance” in the mathematical sense.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feature</strong> (<em>str</em>) – Feature of the datasets to compare. This must be continuous.</p></li>
<li><p><strong>bins</strong> (<em>int</em><em> or </em><em>str</em><em> or </em><em>None</em><em>, </em><em>default &quot;auto&quot;</em>) – The binning method to use. If <cite>int</cite>, is the number of bins. If
<cite>str</cite>, must be a method accepted by <cite>numpy.histogram_bin_edges</cite>.
If <cite>None</cite>, the feature is assumed to be categorical and counts
are taken for each value in either dataset.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments for <cite>scipy.stats.entropy</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The computed divergence between the distributions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.entropy</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This is a wrapper function for <cite>scipy.stats.entropy</cite>. Since this
function expects a probability vector, the data is first discretised
into evenly-spaced bins.</p>
<p>We can think of the Kullback-Leibler divergence as a measure of
surprise we might expect seeing an example from the real data,
relative to the distribution of the synthetic.</p>
<p>The divergence is zero if the distributions are identical, and
larger values indicate that the two discretised distributions are
further from one another.</p>
<p>An optimal ‘bins’ value has not been suggested.</p>
<p>BUG: returns <cite>inf</cite> if no real data falls in any one of the bins -
dividing by zero error.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_real</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">synth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_synth</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The first feature appears to be more similar than the second across
datasets.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kullback_leibler</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">0.03389133708660097 # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kullback_leibler</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">0.58739109417064730 # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.mann_whitney">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">mann_whitney</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/univariate.html#mann_whitney"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.mann_whitney" title="Permalink to this definition"></a></dt>
<dd><p>Mann-Whitney U test.</p>
<p>The Mann-Whitney test compares two sets of data by examining how
well-mixed they are when pooled. This is acheived by ranking the
pooled data. A low p-value suggests the data are not similar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feature</strong> (<em>str</em>) – Feature of the datasets to compare. This must be continuous.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments for <cite>scipy.stats.mannwhitneyu</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>statistic</strong> (<em>float</em>) – The Mann-Whitney U statistic, in particular U for <cite>synth</cite>.</p></li>
<li><p><strong>pvalue</strong> (<em>float</em>) – Two-sided p-value assuming an asymptotic normal distribution.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.mannwhitneyu</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This is a wrapper function for <cite>scipy.stats.mannwhitneyu</cite>.</p>
<p>The null hypothesis for this test is that for randomly selected real
and synthetic values, the probability that the real value is greater
than the synthetic is the same as the probability that the synthetic
value is greater than the real.</p>
<p>We reject this hypothesis if the p-value is suitably small. This
would in turn suggest that the synthetic and real data are not
similarly distributed.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_real</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">synth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_synth</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>If we were to choose our p-value threshold as 0.05, we would reach
the conclusion that the distributions of the first feature are
similar but the distributions of the second feature are not.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mann_whitney</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">MannwhitneyuResult(statistic=126910.0, pvalue=0.6758436855431454) # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mann_whitney</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">MannwhitneyuResult(statistic=134107.0, pvalue=0.04613704446362845) # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.wasserstein">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">wasserstein</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/univariate.html#wasserstein"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.wasserstein" title="Permalink to this definition"></a></dt>
<dd><p>The (first) Wasserstein distance.</p>
<p>Also known as the “Earth Mover’s” distance, this metric can be
thought of as calculating the amount of “work” required to move from
the distribution of the synthetic data to the distribution of the
real data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feature</strong> (<em>str</em>) – Feature of the datasets to compare. This must be continuous.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments for <cite>scipy.stats.wasserstein_distance</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The computed distance between the distributions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.wasserstein_distance</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This is a wrapper for <cite>scipy.stats.wasserstein_distance</cite>.
Computationally, we can find the Wasserstein distance by calculating
the area between the cumulative distribution functions for the two
distributions.</p>
<p>If <span class="math notranslate nohighlight">\(s\)</span> is the synthetic feature distribution, <span class="math notranslate nohighlight">\(r\)</span> is the
real feature distribution, and <span class="math notranslate nohighlight">\(R\)</span> and <span class="math notranslate nohighlight">\(S\)</span> are their
respective cumulative distribution functions, then</p>
<div class="math notranslate nohighlight">
\[W(s, r) = \int_{-\infty}^{+\infty} |S - R|\]</div>
<p>The distance is zero if the distributions are identical and
increases as they become less alike. This method is therefore good
for comparing multiple synthetic datasets, or features within a
dataset, to see which is closest to the real. However, as this is
not a test, there is no threshold distance below which we can claim
the distributions are statistically the same.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_real</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">synth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_synth</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The first feature appears to be more similar than the second across
datasets.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wasserstein</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat1&#39;</span><span class="p">)</span>
<span class="go">0.0688192355094602 # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wasserstein</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">)</span>
<span class="go">0.8172329918412307 # random</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="synthgauge.metrics.wilcoxon">
<span class="sig-prename descclassname"><span class="pre">synthgauge.metrics.</span></span><span class="sig-name descname"><span class="pre">wilcoxon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/synthgauge/metrics/univariate.html#wilcoxon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#synthgauge.metrics.wilcoxon" title="Permalink to this definition"></a></dt>
<dd><p>Wilcoxon signed-rank test.</p>
<p>In this use, the Wilcoxon test compares the distributions of paired
data. It does this by ranking the pairwise differences between the
real and synthetic data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the real data.</p></li>
<li><p><strong>synth</strong> (<em>pandas.DataFrame</em>) – Dataframe containing the synthetic data.</p></li>
<li><p><strong>feature</strong> (<em>str</em>) – Feature of the datasets to compare. This must be continuous.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments for <cite>scipy.stats.wilcoxon</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>statistic</strong> (<em>float</em>) – The sum of the ranks of the differences above or below zero,
whichever is greater.</p></li>
<li><p><strong>pvalue</strong> (<em>float</em>) – Two-sided p-value.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.wilcoxon</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This is a wrapper function for <cite>scipy.stats.wilcoxon</cite>.</p>
<p>The null hypothesis for this test is that the median of the paired
differences is zero. The alternative hypothesis is that it is
different from zero. This would suggest that the synthetic and real
data are not similarly distributed.</p>
<p>This test only makes sense when the synthetic and real data are
paired. That is, each synthetic datum is matched to a real one. In
which case, it is required that data are ordered to reflect this.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_real</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">synth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">get_synth</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="s1">&#39;feat3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>If we were to choose our p-value threshold as 0.05, we would reach
the conclusion that the distributions of the first feature are
similar but of the second feature are not.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wilcoxon</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat1&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">WilcoxonResult(statistic=58917.0, pvalue=0.25131501183065175) # random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wilcoxon</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">synth</span><span class="p">,</span> <span class="s1">&#39;feat2&#39;</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">WilcoxonResult(statistic=54474.0, pvalue=0.011678503879013464) # random</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="synthgauge" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="classification/index.html" class="btn btn-neutral float-right" title="synthgauge.metrics.classification" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Data Science Campus.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>